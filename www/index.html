<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="format-detection" content="telephone=no" />
  <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height, target-densitydpi=device-dpi" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="stylesheet" href="css/index.css">
  <title>Demo 2</title>
</head>
<body>
  <div id="header" data-theme="e" data-role="header" data-position="fixed">
    <a href="index.html">BACK</a>
    <input type="button" value="Spineboy" onclick="load('spineboy')">
    <input type="button" value="Goblins" onclick="load('goblins')">
  </div>
  <div data-role="content">
    <canvas id="canvas" width="640" height="480"/>
  </div>
  <!-- Phonegap -->
  <script type="text/javascript" src="phonegap.js"></script>
  <!-- Spine.js -->
  <script type="text/javascript" src="js/spine/spine.js"></script>
  <script type="text/javascript" src="js/spine/turbulenzengine.js"></script>
  <script type="text/javascript" src="js/spine/graphicsdevice.js"></script>
  <script type="text/javascript" src="js/spine/draw2d.js"></script>
  <script type="text/javascript" src="js/spine/SpriteBatch.js"></script>
  <script type="text/javascript">

    // Wait for PhoneGap to load
    //
    function onLoad() {
      alert('onload');
        document.addEventListener("deviceready", onDeviceReady, false);
    }

    // PhoneGap is ready
    //
    function onDeviceReady() {
      alert('1');
      window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, onFSSuccess, onFSError);
      alert('2');
    }

    var fileSystem;

    function onFSSuccess(fs) {
      fileSystem = fs;

      alert('fs - ok');

      console.log("Got the file system: " + fileSystem.name);
      console.log("root entry name is " + fileSystem.root.name);

      alert('fs root: ' + fileSystem.root.name);
    }

    function onFSError() {
      alert('fs - fail');
      console.error('Failed work with file system');
      console.log(arguments);
    }

    WebGLTurbulenzEngine.prototype.request = function (url, callback) {
      alert('request - ' + url);
      fileSystem.root.getFile(url, {}, function(fileEntry) {
        fileEntry.file(function(file) {
            var reader = new FileReader();
            reader.onloadend = function(e) {
            alert(this.result);
            callback(this.result, 0)
          };
          reader.readAsText(file);
        }, onError);
      }, onError);
    }

    var canvas = document.getElementById("canvas");
    var TurbulenzEngine = WebGLTurbulenzEngine.create({canvas: canvas});
    var graphicsDevice = TurbulenzEngine.createGraphicsDevice({});
    var draw2D = Draw2D.create({graphicsDevice: graphicsDevice});

    var skeletonName;
    function load (name) {
      skeletonName = name;
      TurbulenzEngine.request("res/spine/" + skeletonName + ".atlas", loadAtlas);
    }

    var atlas;
    function loadAtlas (atlasText) {
      var textureCount = 0;
      atlas = new spine.Atlas(atlasText, {
        load: function (page, path) {
          textureCount++;
          graphicsDevice.createTexture({
            src: "res/spine/" + path,
            mipmaps: true,
            onload: function (texture) {
              page.rendererObject = texture;
              page.width = texture.width;
              page.height = texture.height;
              atlas.updateUVs(page);
              textureCount--;
            }
          });
        },
        unload: function (texture) {
          texture.destroy();
        }
      });
      function waitForTextures () {
        if (!textureCount)
        TurbulenzEngine.request("res/spine/" + skeletonName + ".json", loadSkeletonData);
        else
        setTimeout(waitForTextures, 100);
      }
      waitForTextures();
    }

    var skeletonData;
    function loadSkeletonData (skeletonText) {
      var json = new spine.SkeletonJson(new spine.AtlasAttachmentLoader(atlas));
      skeletonData = json.readSkeletonData(JSON.parse(skeletonText));
      start();
    }

    function start () {
      spine.Bone.yDown = true;

      var skeleton = new spine.Skeleton(skeletonData);
      skeleton.getRootBone().x = 320;
      skeleton.getRootBone().y = 440;
      skeleton.updateWorldTransform();

      var stateData = new spine.AnimationStateData(skeletonData);	
      var state = new spine.AnimationState(stateData);

      if (skeletonName == "spineboy") {
        stateData.setMixByName("walk", "jump", 0.2);
        stateData.setMixByName("jump", "walk", 0.4);
        state.setAnimationByName("walk", true);

        canvas.onmousedown = function () {
          state.setAnimationByName("jump", false);
          state.addAnimationByName("walk", true);
        }
        } else {
        skeleton.setSkinByName("goblingirl");
        skeleton.setSlotsToSetupPose();
        state.setAnimationByName("walk", true);

        canvas.onmousedown = function () {
          skeleton.setSkinByName(skeleton.skin.name == "goblin" ? "goblingirl" : "goblin");
          skeleton.setSlotsToSetupPose();
        }
      }

      var bgColor = [0.9, 0.9, 0.9, 1.0];
      var batch = new SpriteBatch(draw2D);
      var lastTime = TurbulenzEngine.time;
      function update() {
        if (!graphicsDevice) return;

        var delta = TurbulenzEngine.time - lastTime;
        lastTime = TurbulenzEngine.time;
        state.update(delta);
        state.apply(skeleton);
        skeleton.updateWorldTransform();

        graphicsDevice.clear(bgColor, 1.0);
        batch.begin(draw2D.blend.alpha);
        drawSkeleton(batch, skeleton);
        batch.end();
        graphicsDevice.endFrame();
      }

      TurbulenzEngine.setInterval(update, 1000 / 60);
    }

    var vertices = [];
    function drawSkeleton (batch, skeleton) {
      var drawOrder = skeleton.drawOrder;
      for (var i = 0, n = drawOrder.length; i < n; i++) {
        var slot = drawOrder[i];
        var attachment = slot.attachment;
        if (!(attachment instanceof spine.RegionAttachment)) continue;
        attachment.computeVertices(slot.bone, vertices);
        batch.add(
        attachment.rendererObject.page.rendererObject,
        vertices[0], vertices[1],
        vertices[6], vertices[7],
        vertices[2], vertices[3],
        vertices[4], vertices[5],
        skeleton.r * slot.r,
        skeleton.g * slot.g,
        skeleton.b * slot.b,
        skeleton.a * slot.a,
        attachment.uvs[0], attachment.uvs[1],
        attachment.uvs[4], attachment.uvs[5]
        );
      }
    }
  </script>
</body>
</html>
